/* recognizeEq.c, Gerard Renardel, 29 January 2014
 *
 * In this file a recognizer acceptExpression is definined that can recognize
 * arithmetical expressions generated by the following BNF grammar:
 *
 * <expression>  ::= <term> { '+'  <term> | '-' <term> }
 *
 * <term>       ::= <factor> { '*' <factor> | '/' <factor> }
 *
 * <factor>     ::= <number> | <identifier> | '(' <expression> ')'
 *
 * Input for the recognizer is the token list constructed by the scanner (in scanner.c).
 * For the recognition of a token list the method of *recursive descent* is used.
 * It relies on the use of three functions for the recognition and processing of
 * terms, factors and expressions, respectively.
 * These three functions are defined with mutual recursion, corresponding with the
 * structure of the BNF grammar.
 */

#include "scanner.h"
#include "recognizeEq.h"
#include <stdio.h>  /* getchar, printf */
#include <stdlib.h> /* NULL */
#include <string.h>

/* The functions acceptNumber, acceptIdentifier and acceptCharacter have as
 * (first) argument a pointer to an token list; moreover acceptCharacter has as
 * second argument a character. They check whether the first token
 * in the list is a number, an identifier or the given character, respectively.
 * When that is the case, they yield the value 1 and the pointer points to the rest of
 * the token list. Otherwise they yield 0 and the pointer remains unchanged.
 */

int acceptNumber(List *lp)
{
    if (*lp != NULL && (*lp)->tt == Number)
    {
        *lp = (*lp)->next;
        return 1;
    }
    return 0;
}

int acceptIdentifier(List *lp)
{
    if (*lp != NULL && (*lp)->tt == Identifier)
    {
        *lp = (*lp)->next;
        return 1;
    }
    return 0;
}

int acceptCharacter(List *lp, char c)
{
    if (*lp != NULL && (*lp)->tt == Symbol && ((*lp)->t).symbol == c)
    {
        *lp = (*lp)->next;
        return 1;
    }
    return 0;
}

// checks the number of identifiers and the maximum exponent of the identifier
void helper(List *lp, char **prev, int *numOfIdentifiers, int *maxExp)
{
    while (*lp != NULL)
    {
        if ((*lp)->tt == Identifier)
        {
            size_t len = strlen((*lp)->t.identifier);
            char *currentIdentifier = malloc(len + 1);
            strcpy(currentIdentifier, (*lp)->t.identifier);
            acceptIdentifier(lp);

            // Check the maximum exponent of the identifier
            if (acceptCharacter(lp, '^'))
            {
                int n = (int)(*lp)->t.number;
                if (n > *maxExp)
                {
                    *maxExp = n;
                }
                *lp = (*lp)->next;
            }
            else
            {
                if (*maxExp < 1)
                {
                    *maxExp = 1;
                }
            }

            // Increase the number of identifiers if currentIdentifier is different from prev
            if (strcmp(currentIdentifier, *prev) != 0)
            {
                (*numOfIdentifiers)++;
                free(*prev);
                *prev = malloc(strlen(currentIdentifier) + 1);
                if (*prev == NULL)
                {
                    perror("malloc");
                    exit(EXIT_FAILURE);
                }
                strcpy(*prev, currentIdentifier);
            }
            free(currentIdentifier);
        }
        else
        {
            // Skip tokens that are not identifiers.
            *lp = (*lp)->next;
        }
    }
}

/* The functions acceptFactor, acceptTerm and acceptExpression have as
 * argument a pointer to a token list. They check whether the token list
 * has an initial segment that can be recognized as factor, term or expression, respectively.
 * When that is the case, they yield the value 1 and the pointer points to the rest of
 * the token list. Otherwise they yield 0 and the pointer remains unchanged.
 */

int acceptTerm(List *lp)
{
    // checking for valid expressions of the form ax^b or sub-expression of that
    if (acceptNumber(lp))
    {
        if (acceptIdentifier(lp))
        {
            if (acceptCharacter(lp, '^'))
            {
                if (acceptNumber(lp))
                {
                    return 1;
                }
                return 0;
            }
            return 1;
        }
        return 1;
    }
    else if (acceptIdentifier(lp))
    {
        if (acceptCharacter(lp, '^'))
        {
            if (acceptNumber(lp))
            {
                return 1;
            }
            return 0;
        }
        return 1;
    }
    return 0;
}

int acceptExpression(List *lp)
{
    acceptCharacter(lp, '-');

    if (!acceptTerm(lp))
    {

        return 0;
    }

    while (acceptCharacter(lp, '+') || acceptCharacter(lp, '-'))
    {
        if (!acceptTerm(lp))
        {
            return 0;
        }
    }
    return 1;
}

int acceptEquation(List *lp)
{
    if (acceptExpression(lp) && acceptCharacter(lp, '=') && acceptExpression(lp))
    {

        return 1;
    }
    return 0;
}

void recognizeEquations()
{
    char *ar;
    List tl, tl1;
    printf("give an equation: ");
    ar = readInput();
    while (ar[0] != '!')
    {
        char *prev = malloc(1);
        prev[0] = '\0';

        int numOfIdentifiers = 0;
        int maxExp = 0;
        tl = tokenList(ar);
        printList(tl);
        tl1 = tl;

        if (acceptEquation(&tl1) && tl1 == NULL)
        {
            List tl2 = tl;
            helper(&tl2, &prev, &numOfIdentifiers, &maxExp);
            printf("this is an equation");
            if (numOfIdentifiers == 1)
            {
                printf(" in 1 variable of degree %d\n", maxExp);
            }
            else
            {
                printf(", but not in 1 variable\n");
            }
        }
        else
        {
            printf("this is not an equation\n");
        }
        free(ar);
        free(prev);
        freeTokenList(tl);

        printf("\ngive an equation: ");
        ar = readInput();
    }
    free(ar);
    printf("good bye\n");
}
